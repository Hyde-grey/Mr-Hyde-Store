/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/ChromeSpace/ChromeSpace.glb --types 
*/
// @ts-nocheck
import * as THREE from "three";
import React, { useEffect, useRef, useState } from "react";
import { useFrame, useGraph } from "@react-three/fiber";
import { useGLTF, PerspectiveCamera, useScroll } from "@react-three/drei";
import { GLTF, SkeletonUtils } from "three-stdlib";
import { useAnimation } from "../../context/AnimationContext";

type ActionName = "Action";

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    ChromeCross: THREE.Mesh;
    ChromeGrill: THREE.Mesh;
    asteroid_low_Aster_0: THREE.Mesh;
    Astro_suit_0: THREE.Mesh;
    Astro_suit_accessories_0: THREE.Mesh;
    Astro_suit_visor_0: THREE.Mesh;
    polySurface280_Green_0: THREE.Mesh;
    Camera: THREE.PerspectiveCamera;
  };
  materials: {
    Chrome: THREE.MeshStandardMaterial;
    ["Material.001"]: THREE.MeshStandardMaterial;
    suit: THREE.MeshStandardMaterial;
    suit_accessories: THREE.MeshStandardMaterial;
    suit_visor: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

export function ChromeSpaceModel() {
  const { isAnimating, setIsAnimating, setFadeOpacity } = useAnimation();
  const group = useRef<THREE.Group>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera>(null);
  const scroll = useScroll();
  const radius = 200;
  const animationStartTime = useRef<number | null>(null);
  const initialCameraPosition = useRef<THREE.Vector3 | null>(null);
  const hasStartedAnimation = useRef(false);

  const { scene } = useGLTF("ChromeSpace/ChromeSpace.glb");

  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone) as GLTFResult;

  useEffect(() => {
    if (nodes.Camera && cameraRef.current) {
      cameraRef.current.position.copy(nodes.Camera.position);
      cameraRef.current.rotation.copy(nodes.Camera.rotation);
    }
  }, [nodes]);

  useFrame(({ camera, clock }) => {
    if (group.current && !isAnimating) {
      // Normal orbital camera movement during scroll
      const angleOffset = Math.PI / 2;
      const angle = scroll.offset * Math.PI * 4 + angleOffset;
      const x = group.current.position.x + radius * Math.cos(angle);
      const z = group.current.position.z + radius * Math.sin(angle);

      camera.position.set(x, group.current.position.y, z);
      camera.lookAt(group.current.position);
    } else if (isAnimating && group.current) {
      // Start animation from current camera position
      if (!initialCameraPosition.current) {
        initialCameraPosition.current = camera.position.clone();
        animationStartTime.current = clock.getElapsedTime();
        return; // Skip first frame to prevent jump
      }

      const elapsed =
        clock.getElapsedTime() - (animationStartTime.current || 0);
      const duration = 2;

      if (elapsed < duration) {
        const t = elapsed / duration;
        const easeInOutQuad =
          t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

        const targetPosition = new THREE.Vector3(
          group.current.position.x + 50,
          group.current.position.y + 30,
          group.current.position.z + 50
        );

        camera.position.lerpVectors(
          initialCameraPosition.current,
          targetPosition,
          easeInOutQuad
        );

        // Create two look-at targets and interpolate between them
        const asteroidPosition = new THREE.Vector3(0, 0, 0); // asteroid_low_Aster_0 position
        const skullPosition = new THREE.Vector3(0.126, 2.393, 0); // ChromeGrill position

        // Switch look-at target halfway through the animation
        const lookAtTarget =
          t < 0.5
            ? asteroidPosition
            : asteroidPosition.lerp(skullPosition, (t - 0.5) * 2);

        camera.lookAt(lookAtTarget);
      } else {
        setFadeOpacity(1);
        setIsAnimating(false);
      }
    }
  });

  const handlePlay = () => {
    // This method is no longer used in the updated component
  };

  useEffect(() => {
    if (nodes.Camera) {
      cameraRef.current = nodes.Camera;
    }
  }, [nodes]);

  return (
    <group ref={group} dispose={null} scale={0.1}>
      {isAnimating && (
        <mesh position={[0, 0, -1]} renderOrder={1000}>
          <planeGeometry args={[100, 100]} />
          <meshBasicMaterial
            transparent
            opacity={isAnimating ? setFadeOpacity : 0}
            color="black"
            depthTest={false}
          />
        </mesh>
      )}
      <group name="Scene">
        <PerspectiveCamera
          name="Camera"
          makeDefault={true}
          fov={40.895}
          far={9000}
          near={0.1}
          position={[-8.166, -38.953, 447.777]}
          rotation={[0.154, -0.019, 0.003]}
        />
        <mesh
          name="ChromeCross"
          geometry={nodes.ChromeCross.geometry}
          material={materials.Chrome}
          position={[-10.396, -24.096, -17.18]}
          rotation={[2.143, -0.38, -2.865]}
          scale={0.605}
        />
        <mesh
          name="ChromeGrill"
          geometry={nodes.ChromeGrill.geometry}
          material={materials.Chrome}
          position={[0.326, 28.393, -3.2]}
          rotation={[-0.591, 0, -Math.PI]}
          scale={5.008}
        />
        <mesh
          name="asteroid_low_Aster_0"
          geometry={nodes.asteroid_low_Aster_0.geometry}
          material={
            new THREE.MeshPhysicalMaterial({
              color: 0x111111,
              metalness: 0,
              roughness: 0.8,
              reflectivity: 45,
            })
          }
          position={[0.256, -2.864, -1.332]}
          scale={0.082}
        />
        <mesh
          name="Astro_suit_0"
          geometry={nodes.Astro_suit_0.geometry}
          material={materials.suit}
          position={[0.256, -2.864, -1.332]}
          scale={0.082}
        />
        <mesh
          name="Astro_suit_accessories_0"
          geometry={nodes.Astro_suit_accessories_0.geometry}
          material={materials.suit_accessories}
          position={[0.256, -2.864, -1.332]}
          scale={0.082}
        />
        <mesh
          name="Astro_suit_visor_0"
          geometry={nodes.Astro_suit_visor_0.geometry}
          material={materials.suit_visor}
          position={[0.256, -2.864, -1.332]}
          scale={0.082}
        />
        <mesh
          name="polySurface280_Green_0"
          geometry={nodes.polySurface280_Green_0.geometry}
          material={nodes.polySurface280_Green_0.material}
          position={[0.256, -2.864, -1.332]}
          rotation={[-1.431, -0.112, -0.772]}
          scale={0.005}
        />
      </group>
    </group>
  );
}

// Add method to start animation
export const startChromeSpaceAnimation = () => {
  // This method is no longer used in the updated component
};
