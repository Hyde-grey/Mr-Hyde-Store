/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/ChromeSpace/ChromeSpace.glb --types 
*/

// @ts-nocheck

import * as THREE from "three";
import React, { useEffect, useRef, useState } from "react";
import { useFrame, useGraph } from "@react-three/fiber";
import {
  useGLTF,
  PerspectiveCamera,
  useAnimations,
  useScroll,
} from "@react-three/drei";
import { GLTF, SkeletonUtils } from "three-stdlib";
import { useAnimationControls } from "framer-motion";

type ActionName = "Action";

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    ChromeCross: THREE.Mesh;
    ChromeGrill: THREE.Mesh;
    asteroid_low_Aster_0: THREE.Mesh;
    Astro_suit_0: THREE.Mesh;
    Astro_suit_accessories_0: THREE.Mesh;
    Astro_suit_visor_0: THREE.Mesh;
    polySurface280_Green_0: THREE.Mesh;
  };
  materials: {
    Chrome: THREE.MeshStandardMaterial;
    ["Material.001"]: THREE.MeshStandardMaterial;
    suit: THREE.MeshStandardMaterial;
    suit_accessories: THREE.MeshStandardMaterial;
    suit_visor: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

export function ChromeSpaceModel(props: JSX.IntrinsicElements["group"]) {
  const [isAnimating, setIsAnimating] = useState(false);
  const group = React.useRef<THREE.Group>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera>(null);
  const scroll = useScroll();
  const radius = 200; // Radius of the circular path

  const { scene, animations } = useGLTF("ChromeSpace/ChromeSpace.glb");

  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone) as GLTFResult;
  const { actions, names } = useAnimations(animations, group);

  // New useEffect to capture initial camera position and rotation
  useEffect(() => {
    if (nodes.Camera && cameraRef.current) {
      cameraRef.current.position.copy(nodes.Camera.position);
      cameraRef.current.rotation.copy(nodes.Camera.rotation);
    }
  }, [nodes]);

  useFrame(({ camera }) => {
    if (group.current && !isAnimating) {
      const angleOffset = Math.PI / 2; // Adjust this value to control the initial facing direction
      const angle = scroll.offset * Math.PI * 4 + angleOffset; // Calculate angle based on scroll offset
      const x = group.current.position.x + radius * Math.cos(angle);
      const z = group.current.position.z + radius * Math.sin(angle);

      camera.position.set(x, group.current.position.y, z); // Set camera position in a circular path relative to the group
      camera.lookAt(group.current.position); // Make the camera look at the group's position
    }
  });

  const handlePlay = () => {
    if (actions && !!names?.length) {
      const action = actions[names[0]];
      action.setLoop(THREE.LoopOnce); // Set the loop mode to LoopOnce
      console.log("group has been clicked");

      // Synchronize camera position and rotation with the start of the animation
      if (nodes.Camera) {
        cameraRef.current.position.copy(nodes.Camera.position);
        cameraRef.current.rotation.copy(nodes.Camera.rotation);
      }

      setIsAnimating(true);
      action.play();
      action.clampWhenFinished = true;

      // Reset the state and stop the animation when it completes
      action.getMixer().addEventListener("finished", () => {
        action?.stop();
        setIsAnimating(false);
      });
    }
  };

  useEffect(() => {
    if (nodes.Camera) {
      cameraRef.current = nodes.Camera;
    }
  }, [nodes]);

  return (
    <group
      ref={group}
      {...props}
      dispose={null}
      onClick={handlePlay}
      scale={0.1}
    >
      <group name="Scene">
        <PerspectiveCamera
          name="Camera"
          makeDefault={true}
          fov={40.895}
          far={9000}
          near={0.1}
          position={[-8.166, -38.953, 447.777]}
          rotation={[0.154, -0.019, 0.003]}
        />
        <mesh
          name="ChromeCross"
          geometry={nodes.ChromeCross.geometry}
          material={materials.Chrome}
          position={[-10.396, -24.096, -17.18]}
          rotation={[2.143, -0.38, -2.865]}
          scale={0.605}
        />
        <mesh
          name="ChromeGrill"
          geometry={nodes.ChromeGrill.geometry}
          material={materials.Chrome}
          position={[0.326, 28.393, -3.2]}
          rotation={[-0.591, 0, -Math.PI]}
          scale={5.008}
        />
        <mesh
          name="asteroid_low_Aster_0"
          geometry={nodes.asteroid_low_Aster_0.geometry}
          material={
            new THREE.MeshPhysicalMaterial({
              color: 0x111111,
              metalness: 0,
              roughness: 0.8,
              reflectivity: 45,
            })
          }
          position={[0.256, -2.864, -1.332]}
          scale={0.082}
        />
        <mesh
          name="Astro_suit_0"
          geometry={nodes.Astro_suit_0.geometry}
          material={materials.suit}
          position={[0.256, -2.864, -1.332]}
          scale={0.082}
        />
        <mesh
          name="Astro_suit_accessories_0"
          geometry={nodes.Astro_suit_accessories_0.geometry}
          material={materials.suit_accessories}
          position={[0.256, -2.864, -1.332]}
          scale={0.082}
        />
        <mesh
          name="Astro_suit_visor_0"
          geometry={nodes.Astro_suit_visor_0.geometry}
          material={materials.suit_visor}
          position={[0.256, -2.864, -1.332]}
          scale={0.082}
        />
        <mesh
          name="polySurface280_Green_0"
          geometry={nodes.polySurface280_Green_0.geometry}
          material={nodes.polySurface280_Green_0.material}
          position={[0.256, -2.864, -1.332]}
          rotation={[-1.431, -0.112, -0.772]}
          scale={0.005}
        />
      </group>
    </group>
  );
}
