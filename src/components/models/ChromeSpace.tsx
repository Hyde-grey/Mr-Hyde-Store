/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/ChromeSpace/ChromeSpace.gltf --types 
*/
//@ts-nocheck
import * as THREE from "three";
import React, { Suspense, useEffect, useRef, useState } from "react";
import { useFrame, useGraph } from "@react-three/fiber";
import {
  useGLTF,
  PerspectiveCamera,
  useAnimations,
  useScroll,
} from "@react-three/drei";
import { GLTF, SkeletonUtils } from "three-stdlib";
import Loading from "./Loading";

type ActionName = "Action";

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    asteroid_low_Aster_0: THREE.Mesh;
    Astro_suit_0: THREE.Mesh;
    Astro_suit_accessories_0: THREE.Mesh;
    Astro_suit_visor_0: THREE.Mesh;
    polySurface280_Green_0_1: THREE.Mesh;
    polySurface280_Green_0_2: THREE.Mesh;
    Skull: THREE.Mesh;
    ChromeCross: THREE.Mesh;
    ChromeGrill: THREE.Mesh;
    ChromeRing: THREE.Mesh;
  };
  materials: {
    Material: THREE.MeshStandardMaterial;
    suit: THREE.MeshStandardMaterial;
    suit_accessories: THREE.MeshStandardMaterial;
    suit_visor: THREE.MeshStandardMaterial;
    Chrome: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

export function ChromeSpaceModel(props: JSX.IntrinsicElements["group"]) {
  const [isAnimating, setIsAnimating] = useState(false);
  const group = React.useRef<THREE.Group>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera>(null);
  const scroll = useScroll();
  const radius = 200; // Radius of the circular path

  const { scene, animations } = useGLTF("ChromeSpace/ChromeSpace.gltf");
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone) as GLTFResult;
  const { actions, names } = useAnimations(animations, group);

  // New useEffect to capture initial camera position and rotation
  useEffect(() => {
    if (nodes.Camera && cameraRef.current) {
      cameraRef.current.position.copy(nodes.Camera.position);
      cameraRef.current.rotation.copy(nodes.Camera.rotation);
    }
  }, [nodes]);

  useFrame(({ camera }) => {
    if (group.current && !isAnimating) {
      const angleOffset = Math.PI / 2; // Adjust this value to control the initial facing direction
      const angle = scroll.offset * Math.PI * 4 + angleOffset; // Calculate angle based on scroll offset
      const x = group.current.position.x + radius * Math.cos(angle);
      const z = group.current.position.z + radius * Math.sin(angle);

      camera.position.set(x, group.current.position.y, z); // Set camera position in a circular path relative to the group
      camera.lookAt(group.current.position); // Make the camera look at the group's position
    }
  });

  const handlePlay = () => {
    if (actions && !!names?.length) {
      const action = actions[names[0]];
      action.setLoop(THREE.LoopOnce); // Set the loop mode to LoopOnce
      console.log("group has been clicked");

      // Synchronize camera position and rotation with the start of the animation
      if (nodes.Camera) {
        cameraRef.current.position.copy(nodes.Camera.position);
        cameraRef.current.rotation.copy(nodes.Camera.rotation);
      }

      setIsAnimating(true);
      action.play();
      action.clampWhenFinished = true;

      // Reset the state and stop the animation when it completes
      action.getMixer().addEventListener("finished", () => {
        action?.stop();
        setIsAnimating(false);
      });
    }
  };

  useEffect(() => {
    if (nodes.Camera) {
      cameraRef.current = nodes.Camera;
    }
  }, [nodes]);

  return (
    <Suspense fallback={<Loading />}>
      <group
        ref={group}
        {...props}
        dispose={null}
        onClick={handlePlay}
        scale={0.2}
      >
        <group name="Scene">
          <group
            name="Space_Man"
            position={[0.256, -2.864, -1.332]}
            scale={0.082}
          >
            <group name="RootNode">
              <group name="asteroid_low">
                <mesh
                  name="asteroid_low_Aster_0"
                  geometry={nodes.asteroid_low_Aster_0.geometry}
                  material={
                    new THREE.MeshPhysicalMaterial({
                      color: 0x111111,
                      metalness: 0,
                      roughness: 0.8,
                      reflectivity: 45,
                    })
                  }
                />
              </group>
              <group name="Astro">
                <mesh
                  name="Astro_suit_0"
                  geometry={nodes.Astro_suit_0.geometry}
                  material={materials.suit}
                />
                <mesh
                  name="Astro_suit_accessories_0"
                  geometry={nodes.Astro_suit_accessories_0.geometry}
                  material={materials.suit_accessories}
                />
                <mesh
                  name="Astro_suit_visor_0"
                  geometry={nodes.Astro_suit_visor_0.geometry}
                  material={materials.suit_visor}
                />
              </group>
              <group
                name="Flower"
                rotation={[-1.431, -0.112, -0.772]}
                scale={0.057}
              >
                <group name="Flower001">
                  <group name="polySurface280_Green_0">
                    <mesh
                      name="polySurface280_Green_0_1"
                      geometry={nodes.polySurface280_Green_0_1.geometry}
                      material={materials.Chrome}
                    />
                    <mesh
                      name="polySurface280_Green_0_2"
                      geometry={nodes.polySurface280_Green_0_2.geometry}
                      material={nodes.polySurface280_Green_0_2.material}
                    />
                  </group>
                </group>
              </group>
              <group name="Skull001" position={[-0.874, 0, 0]}>
                <mesh
                  name="Skull"
                  geometry={nodes.Skull.geometry}
                  material={materials.Chrome}
                />
              </group>
            </group>
          </group>
          <group
            name="BÃ©zierCircle"
            position={[42.568, 23.293, -8.687]}
            scale={618.979}
          />
          <group
            name="Area"
            position={[-14.854, -32.372, -11.832]}
            rotation={[1.063, -0.43, 1.294]}
            scale={10.547}
          />
          <PerspectiveCamera
            name="Camera"
            makeDefault={true}
            fov={40.895}
            far={20000}
            near={0.1}
            position={[-8.166, -38.953, 447.777]}
            rotation={[0.154, -0.019, 0.003]}
          />
          <spotLight
            intensity={0.03}
            angle={0.295}
            penumbra={0.15}
            decay={1}
            color="#ff1200"
            position={[-1.526, -39.359, -9.144]}
            rotation={[1.161, 0.476, 1.469]}
            scale={2.3}
            target={nodes.Spot.target}
          >
            <primitive object={nodes.Spot.target} position={[0, 0, -1]} />
          </spotLight>
          <directionalLight
            intensity={1}
            decay={2}
            position={[95.464, 102.455, 78.437]}
            rotation={[-0.914, 0.742, 1.782]}
            scale={1.467}
            target={nodes.Light.target}
          >
            <primitive object={nodes.Light.target} position={[0, 0, -1]} />
          </directionalLight>
          <mesh
            name="ChromeCross"
            geometry={nodes.ChromeCross.geometry}
            material={materials.Chrome}
            position={[-10.396, -24.096, -17.18]}
            rotation={[2.143, -0.38, -2.865]}
            scale={0.605}
          />
          <mesh
            name="ChromeGrill"
            geometry={nodes.ChromeGrill.geometry}
            material={materials.Chrome}
            position={[0.326, 28.393, -3.2]}
            rotation={[-0.591, 0, -Math.PI]}
            scale={5.008}
          />
          <mesh
            name="ChromeRing"
            geometry={nodes.ChromeRing.geometry}
            material={materials.Chrome}
            position={[0.18, 29.882, 5.275]}
            rotation={[1.083, 0, 0]}
            scale={-0.213}
          />
        </group>
      </group>
    </Suspense>
  );
}

useGLTF.preload("ChromeSpace/ChromeSpace.gltf");
